<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Open Graph Protocol -->
    <meta property="og:title" content="VCT.one" />
    <meta property="og:image" content="//VCT.one/res/vct.one_logo.png" />
    <meta property="og:description" content="Vınсenт's online portfolio." />
    <meta property="og:url" content="//VCT.one/" />

    <!-- JQuery -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

    <!-- style -->
	<link rel="stylesheet" href="/css/main.css">
    <script src="/js/style.js"></script>
    
    <link rel="shortcut icon" href="/res/vct2019_4rounded.png">
    
	<title>Code Samples | VCT.one</title>
</head>
<body onload="setup(); adjust();" onresize="adjust()">

    <!--top bar-->
    <nav>
        <a href="/"><img id="logo" src="/res/vct.one_logo.png" alt="VCT.one logo" /></a>
    </nav>
    <!--top bar end-->
    
    <h1 class="section-label">Code Samples</h1>

    <article class="card" id="table-of-contents">
        <h1>Table of Contents</h1>
        <ul>
            <li>
                <a href="#unity">Unity / C#</a>
                <ul>
                    <li><a href="#sas-destruction">Dynamic destruction for Supermarine Air Support</a></li>
                    <li><a href="#level-object-mover">Displaying objects within bounds for VRgora</a></li>
                    <li><a href="#sas-level-generator">Level generator for Supermarine Air Support</a></li>
                </ul>
            </li>
        </ul>
    </article>

    <h1 class="section-label" id="unity">Unity / C#</h1>

    <article class="card" id="sas-destruction">
        <h1>Dynamic destruction for Supermarine Air Support</h1>
        <p>
            I wrote this dynamic destruction system for <a href="/games/supermarineairsupport/">Supermarine Air Support</a>.<br>
            <br>
            <b>Hitpoints</b><br>
            <br>
            With the following script attached as a component to a GameObject, you can set its <code>hitpoints</code> in the inspector. The script can handle damage calculation based on collision impact strengths, and makes the object shatter into pieces when the <code>hitpoints</code> field reaches a value of 0.<br>
            <br>
            If you don't want certain other objects to cause damage to the one with the script, you can add their names to the <code>passiveDamageExemptionList</code>. In Supermarine Air Support we mainly used this to avoid having the protagonist cause damage to the environment.<br>
            <br>
            <b>Debris</b><br>
            <br>
            When 0 <code>hitpoints</code> are reached, 9 debris pieces (<code>debrisInstance</code>s) are generated, taking their shape and texture from a <code>debrisObject</code> and their color from the original object's texture, and launched into different directions.* The original object is simultaneously dissolved.<br>
            If the <code>debrisObject</code> is destructible using this system too, which in Supermarine Air Support it always is, you can use the <code>debrisHitpoints</code> integer to set the amount of hitpoints the debris should be generated with.<br>
            If the <code>keepAsBackground</code> field is set to true, a darkened, non-interactive version of the original object will remain in the background of the game instead of having the object disappear entirely.<br>
            <br>
            *Debris pieces are not generated in case they would be smaller than a certain threshold or very transparent.<br>
            <br>
            <b>Explosions</b><br>
            <br>
            When the object is <code>explosive</code>, an instance of its <code>explosionObject</code> is created in addition to debris and all objects with Rigidbody2D physics simulation within <code>explosionRadius</code> will be impacted by the explosion's "shockwave". The higher the value of <code>explosionStrength</code> the more.
        </p>
        <pre><code><textarea readonly class="code">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[RequireComponent (typeof(SpriteRenderer))]
public class HitpointImpactDestroyer : MonoBehaviour
{
    [SerializeField] public float hitpoints = 1;
    
    [Header("Damage Exemptions")]
    [Tooltip("Objects with names in this list can not damage this object.")]
    [SerializeField] private List<string> passiveDamageExemptionList = new List<string>();
    
    [Header("Debris Settings")]
    [SerializeField] private GameObject debrisObject = null;
    [SerializeField] private int debrisHitpoints = 1;
    [SerializeField] private bool logDamageTaken = false;

    [Header("Explosion Settings")]
    [SerializeField] private bool explosive = false;
    [SerializeField] private GameObject explosionObject = null;
    [SerializeField] private float explosionRadius = 1;
    [SerializeField] private float explosionStrength = 1;

    [Header("Other")]
    [SerializeField] private bool keepAsBackground = false;

    private bool dissolving = false;
    private bool keptAsBackground = false;

    void Update()
    {
        SpriteRenderer spriteRenderer = GetComponent<SpriteRenderer>();

        //fall apart if hitpoints lost
        if (debrisObject && hitpoints <= 0 && !dissolving) {

            float ppu = spriteRenderer.sprite.pixelsPerUnit;
            int height = spriteRenderer.sprite.texture.height;
            int width = spriteRenderer.sprite.texture.width;
            Bounds srBounds = spriteRenderer.bounds;
            Vector2 impactVelocity = new Vector2();

            //disable collider and rigidbody if possible
            if (GetComponent<Collider2D>()) {
                GetComponent<Collider2D>().enabled = false;
            }
            if (GetComponent<Rigidbody2D>()) {
                impactVelocity = GetComponent<Rigidbody2D>().velocity;
                GetComponent<Rigidbody2D>().isKinematic = true;
            }

            int debrisNumber = 0;
            
            //create and set up debris objects
            for (int iy = 1; iy < 11; iy += 4) {
                for (int ix = 1; ix < 11; ix += 4) {
                    
                    //get color for debris
                    Color color = spriteRenderer.sprite.texture.GetPixel(ix * (int)Mathf.Round(width / 11), iy * (int)Mathf.Round(height / 11)) * spriteRenderer.color;

                    //instantiate and set up objets
                    //if the objects are going to be large and rather opaque
                    if (
                        color.a > 0.3f &&
                        (transform.localScale.x * (width / ppu) / 3 + transform.localScale.y * (height / ppu) / 3) / 2 > 0.2f
                    ) {
                        
                        GameObject debrisInstance = Instantiate(
                            debrisObject,
                            new Vector3(
                                srBounds.min.x + transform.localScale.x * ix * (width / ppu) / 11,
                                srBounds.min.y + transform.localScale.y * iy * (height / ppu) / 11,
                                transform.position.z
                            ),
                            transform.rotation
                        );

                        //give debris hitpoints if it has this component too
                        if (debrisInstance.GetComponent<HitpointImpactDestroyer>()) {
                            debrisInstance.GetComponent<HitpointImpactDestroyer>().hitpoints = debrisHitpoints;
                        }

                        //set up debris rigidbody
                        if (debrisInstance.GetComponent<Rigidbody2D>()) {
                            debrisInstance.GetComponent<Rigidbody2D>().isKinematic = false;
                            debrisInstance.GetComponent<Rigidbody2D>().useAutoMass = true;
                            if (GetComponent<Rigidbody2D>()) {
                                
                                //debrisInstance.GetComponent<Rigidbody2D>().velocity = impactVelocity;
                                
                                float directionVectorX = 0;
                                float directionVectorY = 0;
                                
                                if (debrisNumber % 3 == 0) {
                                    directionVectorX = -1;
                                }
                                else if (debrisNumber == 2 || debrisNumber == 5 || debrisNumber == 8) {
                                    directionVectorX = 1;
                                }
                                if (debrisNumber < 3) {
                                    directionVectorY = -1;
                                }
                                else if (debrisNumber > 5) {
                                    directionVectorY = 1;
                                }
                                
                                debrisInstance.GetComponent<Rigidbody2D>().velocity = new Vector2(directionVectorX * impactVelocity.magnitude, directionVectorY * impactVelocity.magnitude);
                            }
                        }
                        if (debrisInstance.GetComponent<Collider2D>()) {
                            debrisInstance.GetComponent<Collider2D>().enabled = true;
                            debrisInstance.GetComponent<Collider2D>().density = GetComponent<Collider2D>().density;
                        }

                        //color and scale debris
                        if (debrisInstance.GetComponent<SpriteRenderer>()) {
                            debrisInstance.GetComponent<SpriteRenderer>().color = color;
                            debrisInstance.transform.localScale = new Vector3(
                                transform.localScale.x * (width / ppu) / 3,
                                transform.localScale.y * (height / ppu) / 3,
                                transform.position.z
                            );
                        }
                    }

                    debrisNumber ++;
                }
            }

            dissolving = true;
        }

        //dissolve at the end
        if (dissolving) {
            
            //destroy some components if possible
            if (GetComponent<Animator>()) {
                Destroy(GetComponent<Animator>());
            }
            if (GetComponent<CollisionSoundEmitter>()) {
                Destroy(GetComponent<CollisionSoundEmitter>());
            }
            if (GetComponent<AudioSource>()) {
                Destroy(GetComponent<AudioSource>());
            }
            if (GetComponent<CharacterMovement>()) {
                Destroy(GetComponent<CharacterMovement>());
            }

            //explode
            if (explosive && explosionObject) {
                explosive = false;
                GameObject explosion = Instantiate(explosionObject, new Vector3(transform.position.x, transform.position.y, transform.position.z - 1), transform.rotation);
                explosion.transform.localScale = new Vector3(explosionRadius, explosionRadius, 1);
                
                CircleCollider2D circleCollider = gameObject.AddComponent(typeof(CircleCollider2D)) as CircleCollider2D;
                circleCollider.radius = explosionRadius;
                circleCollider.isTrigger = true;
                
                List<Collider2D> collidersOfObjectsInExplosionRange = new List<Collider2D>();
                collidersOfObjectsInExplosionRange.ToArray();
                ContactFilter2D noContactFilter = new ContactFilter2D();
                noContactFilter.NoFilter();
                circleCollider.OverlapCollider(noContactFilter, collidersOfObjectsInExplosionRange);
                foreach(Collider2D collider in collidersOfObjectsInExplosionRange) {
                    
                    //throw rigidbody objects away
                    if (collider.gameObject.GetComponent<Rigidbody2D>()) {
                        Rigidbody2D impactedObjectRb = collider.gameObject.GetComponent<Rigidbody2D>();
                        impactedObjectRb.velocity = (Vector3) impactedObjectRb.velocity + explosionStrength * (collider.gameObject.transform.position - transform.position).normalized * (explosionRadius - (collider.gameObject.transform.position - transform.position).magnitude);
                    }

                    //damage objects with hitpoints
                    if (collider.gameObject.GetComponent<HitpointImpactDestroyer>()) {
                        HitpointImpactDestroyer impactedObjectHid = collider.gameObject.GetComponent<HitpointImpactDestroyer>();
                        impactedObjectHid.hitpoints -= 5 * explosionStrength * (explosionRadius - (collider.gameObject.transform.position - transform.position).magnitude);
                    }
                    
                }
            }

            //dissolve / self-destruct
            if (!keepAsBackground) {
                if (spriteRenderer.color.a <= 0) {
                    Destroy(gameObject);
                }
                else {
                    spriteRenderer.color = new Color(spriteRenderer.color.r, spriteRenderer.color.g, spriteRenderer.color.b, spriteRenderer.color.a - Time.deltaTime);
                }
            }
            //keep as background
            else if (!keptAsBackground) {
                //disable collider and rigidbody if possible
                if (GetComponent<Collider2D>()) {
                    GetComponent<Collider2D>().enabled = false;
                }
                if (GetComponent<Rigidbody2D>()) {
                    GetComponent<Rigidbody2D>().isKinematic = true;
                    GetComponent<Rigidbody2D>().simulated = false;
                }
                //move into background
                transform.position = new Vector3(transform.position.x, transform.position.y, transform.position.z + 1);
                //darken
                spriteRenderer.color = new Color(spriteRenderer.color.r - 0.3f, spriteRenderer.color.g - 0.3f, spriteRenderer.color.b - 0.3f, spriteRenderer.color.a);
                keptAsBackground = true;
            }
        }
    }

    void OnCollisionEnter2D(Collision2D collision) {
        
        bool passiveDamageExempt = false;
        foreach(string name in passiveDamageExemptionList) {
            if (collision.collider.name.Contains(name)) {
                passiveDamageExempt = true;
            }
        }

        if (!passiveDamageExempt) {
            
            //kineticEnergy = 0.5 * mass * relativeVelocity ^ 2
            float damage = 0;
            if (collision.rigidbody) {
                damage = 0.5f * collision.rigidbody.mass * Mathf.Pow(collision.relativeVelocity.magnitude, 2);
            }
            else if (collision.collider) {
                damage = 0.5f * collision.collider.bounds.size.x * collision.collider.bounds.size.y * Mathf.Pow(collision.relativeVelocity.magnitude, 2);
            }
            hitpoints -= damage;
            if (damage > 1 && logDamageTaken) {
                Debug.Log(gameObject.name + " took " + damage + " damage from " + collision.gameObject.name);
            }         
            //hitpoints -= collision.relativeVelocity.magnitude;

            if (hitpoints <= 0 && GetComponent<Rigidbody2D>() == null && !dissolving) {
                Rigidbody2D tempRb = gameObject.AddComponent<Rigidbody2D>() as Rigidbody2D;
                tempRb.velocity = 0.5f * collision.relativeVelocity;
                hitpoints = 1;
            }

        }
        
    }

    void OnCollisionStay2D(Collision2D collision) {

        OnCollisionEnter2D(collision);

    }
}  
        </textarea></code></pre>
        <p>
            <img src="/res/supermarine air support/trapping_zombies.gif" alt="animation showing the player trapping zombies in a pit using the dynamic destruction system in Supermarine Air Support"><br>
            In this animation the player makes use of the system to trap three zombies in a pit.<br>
            The player's projectiles, the terrain, the dynamite and the zombies all implement this script. 
        </p>
    </article>

    <article class="card" id="level-object-mover">
        <h1>Displaying objects within bounds for VRgora</h1>
        <p>
            In <a href="/games/vrgora/">VRgora</a> the protagonist moves through a crowded pedestrian street surrounded by buildings.<br>
            <br>
            The houses, "pedestrians" (capsules) and other environmental objects of this prototype level have the <code>LevelObjectMover</code> script attached to them.<br>
            It is responsible for displaying the level objects only when they are within the area above the table (or rather the <code>gameBoard</code> GameObject), and moving them along depending on the protagonist's "speed" (<code>characterWalkSpeed</code>; derived from the <code>character</code> GameObject).<br>
            <br>
            While the level objects only move in one direction in the prototype, quite some code is already prepared within the script to allow movement in four directions. (along the X and Z axes).<br>
            The <code>squish</code> boolean determines whether the objects shall be "squished" into place or faded in / out when appearing / disappearing. In the prototype all objects use the "squishing".<br>
            <br>
            Although I have later learnt that it would have been significantly more performant to have coded this functionality as a GPU run shader, I am quite proud of how it turned out, since it was my first time manipulating 3D meshes using code.
        </p>
        <pre><code><textarea readonly class="code">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class LevelObjectMover : MonoBehaviour
{
    [SerializeField] private GameObject gameBoard = null;
    [SerializeField] private GameObject character = null;
    [SerializeField] private bool useZInteadOfXAxisToScroll = false;
    [SerializeField] private float fadeTime = 1;
    [SerializeField] private bool squish = true;
    private MeshRenderer meshRenderer = null;
    private MeshFilter meshFilter = null;
    private float characterWalkSpeed = 0;
    private bool fading = false;
    private bool visible = false;
    private bool startsOnPositiveSideOfTheAxis = true;
    private bool fadingIn = false;
    private Vector3[] unmodifiedVertices;

    void Start()
    {
        //workaround for attaching game board objects to prefabs using game board object name
        if (gameBoard == null) {
            gameBoard = GameObject.Find("GameBoard");
        }
        //workaround for attaching the character object to prefabs using object name
        if (character == null) {
            character = GameObject.Find("Character");
        }

        meshRenderer = GetComponent<MeshRenderer>();
        meshRenderer.enabled = false;
        //check on which side the object starts
        if (useZInteadOfXAxisToScroll)
        {
            if (transform.position.z < gameBoard.transform.position.z)
            {
                startsOnPositiveSideOfTheAxis = false;
            }
            else
            {
                startsOnPositiveSideOfTheAxis = true;
            }
        }
        else
        {
            if (transform.position.x < gameBoard.transform.position.x)
            {
                startsOnPositiveSideOfTheAxis = false;
            }
            else
            {
                startsOnPositiveSideOfTheAxis = true;
            }
        }
        meshFilter = GetComponent<MeshFilter>();
        unmodifiedVertices = meshFilter.mesh.vertices;
    }

    void Update()
    {
        Collider collider = GetComponent<Collider>();
        Collider gameBoardCollider = gameBoard.GetComponent<Collider>();

        characterWalkSpeed = character.GetComponent<CharacterBehavior>().walkSpeed;
        //move object around character
        if (useZInteadOfXAxisToScroll)
        {
            transform.Translate(new Vector3(0, 0, characterWalkSpeed * Time.deltaTime), Space.World);
        }
        else
        {
            transform.Translate(new Vector3(characterWalkSpeed * Time.deltaTime, 0, 0), Space.World);
        }

        //for non-squishable objects or ones that shouldn't be squished
        if (!squish) {

            //start fading
            if (!fading && useZInteadOfXAxisToScroll)
            {
                //appear if close enough
                if (
                    !visible && Mathf.Abs(transform.position.z - gameBoard.transform.position.z) < gameBoardCollider.bounds.size.z / 2 + collider.bounds.size.z / 2 &&
                    (startsOnPositiveSideOfTheAxis && transform.position.z > gameBoard.transform.position.z || !startsOnPositiveSideOfTheAxis && transform.position.z < gameBoard.transform.position.z)
                )
                {
                    meshRenderer.enabled = true;
                    fading = true;
                    fadingIn = true;
                    Color materialColor = meshRenderer.material.color;
                    materialColor.a = 0;
                    meshRenderer.material.color = materialColor;
                    visible = true;
                }
                //disappear if too far
                else if (
                    Mathf.Abs(transform.position.z - gameBoard.transform.position.z) > gameBoardCollider.bounds.size.z / 2 + collider.bounds.size.z / 2 &&
                    (startsOnPositiveSideOfTheAxis && transform.position.z < gameBoard.transform.position.z || !startsOnPositiveSideOfTheAxis && transform.position.z > gameBoard.transform.position.z)
                )
                {
                    fading = true;
                    fadingIn = false;
                }
            }
            else if (!fading)
            {
                //appear if close enough
                if (
                    !visible && Mathf.Abs(transform.position.x - gameBoard.transform.position.x) < gameBoardCollider.bounds.size.x / 2 + collider.bounds.size.x / 2 &&
                    (startsOnPositiveSideOfTheAxis && transform.position.x > gameBoard.transform.position.x || !startsOnPositiveSideOfTheAxis && transform.position.x < gameBoard.transform.position.x)
                )
                {
                    meshRenderer.enabled = true;
                    fading = true;
                    fadingIn = true;
                    Color materialColor = meshRenderer.material.color;
                    materialColor.a = 0;
                    meshRenderer.material.color = materialColor;
                    visible = true;
                }
                //disappear if too far
                else if (
                    Mathf.Abs(transform.position.x - gameBoard.transform.position.x) > gameBoardCollider.bounds.size.x / 2 + collider.bounds.size.x / 2 &&
                    (startsOnPositiveSideOfTheAxis && transform.position.x < gameBoard.transform.position.x || !startsOnPositiveSideOfTheAxis && transform.position.x > gameBoard.transform.position.x)
                )
                {
                    fading = true;
                    fadingIn = false;
                }
            }
        }

        //for squishable objects
        else {

            //model operations
            Vector3[] vertices = meshFilter.mesh.vertices;
            bool withinDisplayRange = false;
            for (int i = 0; i < vertices.Length; i++) {
                Vector3 vertex = vertices[i];
                Vector3 unmodifiedVertex = unmodifiedVertices[i];
                Vector3 point = transform.TransformPoint(vertex);
                Vector3 unmodifiedPoint = transform.TransformPoint(unmodifiedVertex);
                //squeeze x
                if (unmodifiedPoint.x < gameBoardCollider.bounds.min.x) {
                    point.x = gameBoardCollider.bounds.min.x;
                    vertices[i] = transform.InverseTransformPoint(point);
                }
                else if (unmodifiedPoint.x > gameBoardCollider.bounds.max.x) {
                    point.x = gameBoardCollider.bounds.max.x;
                    vertices[i] = transform.InverseTransformPoint(point);
                }
                else if (point.x != unmodifiedPoint.x) {
                    point.x = unmodifiedPoint.x;
                    vertices[i] = transform.InverseTransformPoint(point);
                }
                //squeeze z
                if (unmodifiedPoint.z < gameBoardCollider.bounds.min.z) {
                    point.z = gameBoardCollider.bounds.min.z;
                    vertices[i] = transform.InverseTransformPoint(point);
                }
                else if (unmodifiedPoint.z > gameBoardCollider.bounds.max.z) {
                    point.z = gameBoardCollider.bounds.max.z;
                    vertices[i] = transform.InverseTransformPoint(point);
                }
                else if (point.z != unmodifiedPoint.z) {
                    point.z = unmodifiedPoint.z;
                    vertices[i] = transform.InverseTransformPoint(point);
                }
                
                //check if it is within display range
                if (
                    unmodifiedPoint.x < gameBoardCollider.bounds.max.x &&
                    unmodifiedPoint.x > gameBoardCollider.bounds.min.x &&
                    unmodifiedPoint.z < gameBoardCollider.bounds.max.z &&
                    unmodifiedPoint.z > gameBoardCollider.bounds.min.z &&
                    !withinDisplayRange
                ) {
                    withinDisplayRange = true;
                }
            }
            meshFilter.mesh.vertices = vertices;
            //start fading
            //in
            if (!fading && !visible && withinDisplayRange) {
                meshRenderer.enabled = true;
                fading = true;
                fadingIn = true;
                Color materialColor = meshRenderer.material.color;
                materialColor.a = 0;
                meshRenderer.material.color = materialColor;
                visible = true;
            }
            //out
            if (!fading && visible && !withinDisplayRange) {
                fading = true;
                fadingIn = false;
            }
        }

        

        //fade
        if (fading)
        {
            //fade in
            if (fadingIn)
            {
                Color materialColor = meshRenderer.material.color;
                materialColor.a += Time.deltaTime / fadeTime; 
                meshRenderer.material.color = materialColor;
                if (meshRenderer.material.color.a >= 1)
                {
                    fading = false;
                    fadingIn = false;
                }
            }
            //fade out
            else
            {
                Color materialColor = meshRenderer.material.color;
                materialColor.a -= Time.deltaTime / fadeTime;
                meshRenderer.material.color = materialColor;
                if (meshRenderer.material.color.a <= 0)
                {
                    fading = false;
                    fadingIn = false;
                    meshRenderer.enabled = false;
                    visible = false;
                }
            }
        }
    }
}            
        </textarea></code></pre>
        <p>
            <img src="/res/vrgora/vrgora_optimized.gif" alt="animated gampeplay of VRgora"><br>
            In this animation you can see the system in action.
        </p>
    </article>

    <article class="card" id="sas-level-generator">
        <h1>Level generator for Supermarine Air Support</h1>
        <p>
            For the project <a href="/games/supermarineairsupport/">Supermarine Air Support</a> I wrote this level generator.<br>
            <br>
            It uses pixel data from an input texture (<code>texture</code>) to instantiate various kinds of game objects at relative coordinates. The generator is given a list of scriptable objects (<code>colorObjectAssignments</code>) to instantiate the correct object based on the pixel color.<br>
            <br>
            Since generating the level entirely at once took a considerable amount of time, I made use of a coroutine (<code>GenerateLevelOverTime</code>) to continously generate parts of the level at runtime. 
        </p>
        <pre><code><textarea readonly class="code">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class LevelGenerator : MonoBehaviour
{

    [SerializeField] private Texture2D texture = null;
    [SerializeField] private ColorGameObjectAssignment[] colorObjectAssignments = null;
    [SerializeField] private int columnsPerFrame = 1;
    [SerializeField] private bool colorDebugMessages = false;
    [Header("Level Finish Properties")]
    [SerializeField] private GameObject failMenuObject = null;
    [Header("Target Coordinates")]
    [Tooltip("the x-coordinate this object has to reach to win")]
    [SerializeField] private float targetX = 100;
    [Tooltip("the object has to reach targetX at this or a higher y-cordinate")]
    [SerializeField] private float minimumTartgetY = 0;
    [Header("Other Level Bounds")]
    [SerializeField] private float minimumLevelX = 0;
    [SerializeField] private float minimumLevelY = 0;
    [SerializeField] private float maximumLevelY = 500; 

    void Start()
    {
        StartCoroutine(GenerateLevelOverTime(columnsPerFrame));
    }

    IEnumerator GenerateLevelOverTime(int columnsPerFrame) {
        
        Color[] pixels = texture.GetPixels();
        
        //iterate through all the pixels of the texture
        int blockNumber = 0;
        for (int x = 0; x < texture.width; x++) {
            for (int y = 0; y < texture.height; y++) {
                    
                bool objectCreatedForThisPixel = false;

                //iterate through color object assignments
                foreach (ColorGameObjectAssignment colorObjectAssignment in colorObjectAssignments) {
                    
                    //check if it matches pixel color
                    if (pixels[blockNumber] == colorObjectAssignment.color) {
                        GameObject gO = Instantiate(
                            colorObjectAssignment.gameObject,
                            new Vector3(x, y, colorObjectAssignment.gameObject.transform.position.z) + colorObjectAssignment.spawnLocationOffset,
                            Quaternion.identity
                        );
                        objectCreatedForThisPixel = true;

                        //special case for the character
                        if (gO.GetComponent<LevelFinisher>()) {
                            LevelFinisher gOLevelFinisher = gO.GetComponent<LevelFinisher>();
                            gOLevelFinisher.failMenuObject = failMenuObject;
                            gOLevelFinisher.targetX = targetX;
                            gOLevelFinisher.minimumTargetY = minimumTartgetY;
                            gOLevelFinisher.minimumLevelX = minimumLevelX;
                            gOLevelFinisher.minimumLevelY = minimumLevelY;
                            gOLevelFinisher.maximumLevelY = maximumLevelY;
                        }

                    }
                }

                if (!objectCreatedForThisPixel && colorDebugMessages) {
                    if (ColorUtility.ToHtmlStringRGB(pixels[blockNumber]) != "FFFFFF") {
                        Debug.Log("The level generator is lacking instructions for color " + ColorUtility.ToHtmlStringRGB(pixels[blockNumber]));
                    }
                }

                if (y == texture.height - 1) {
                    blockNumber -= y * texture.width - 1;
                }
                else {
                    blockNumber += texture.width;
                }
            }
            if (x % columnsPerFrame == 0) {
                yield return null;
            }
        }        
    }
}
        </textarea></code></pre>
    </article>

    <!--recurring page end elements-->
    
    <div id="contact-button">
        <button class="contact" onclick="moveViewTo('footer')">Contact</button>
    </div>

    <div class="space"></div>

    <footer>
        <div class="social-media-icons">
            <a href="https://instagram.com/vct136">
                <img src="/res/instagram_icon.png" alt="Instagram icon" /><br>
                @vct136
            </a>
            <a href="https://linkedin.com/in/vct">
                <img src="/res/linkedin_logo_black.png" alt="LinkedIn icon" /><br>
                Vincent Busch / VCT
            </a>
            <a href="mailto://vct136@gmail.com">
                <img src="/res/email-icon-vindicator-at.svg" alt="at-symbol" /><br>
                VCT136@Gmail.com
            </a>
            <a href="tel:+4917657470599">
                <img src="/res/phone_icon.svg" alt="phone icon" /><br>
                +49 176 5 747 0599
            </a>
            <a href="https://facebook.com/vct136">
                <img src="/res/facebook_f_icon_black.png" alt="Facebook icon" /><br>
                Vincent Busch / VCT136
            </a>
        </div>
        <div>
            VCT.one is the portfolio website of Vincent Busch a.k.a. VCT.
        </div>
        <div>
            ©2021 Vincent Busch
        </div>
        <img class="bottom-left" src="/res/mesitting2021.png" alt="a photo of me sitting" />
        <img class="bottom-right" src="/res/logo.png" alt="VCT logo" />
    </footer>

    <!--page end-->

</body>
</html>